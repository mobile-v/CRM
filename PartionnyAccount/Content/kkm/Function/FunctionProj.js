/* Требуется jquery. */


/*
Источник:
https://kkmserver.ru/KkmServer

https://kkmserver.ru/KkmServer/SamplesAjax.html
view-source:https://kkmserver.ru/KkmServer/SamplesAjax.html
*/



//////////////////////////////////////////////////////////////////////////////////////////
// Вызов команды на сервере Old_AuthorizationCode
//////////////////////////////////////////////////////////////////////////////////////////
//var Device = 2; // Номер устройства
var UrlServer = "http://localhost:5893/"; // HTTP адрес сервера торгового оборудования, если пусто то локальный вызов
var User = "User"; // Пользователь доступа к серверу торгового оборудования
var Password = "30"; // Пароль доступа к серверу торгового оборудования

var Old_RRNCode = ""; // Для Экв. тер.
var Old_AuthorizationCode = ""; // Для Экв. тер.

function ExecuteCommand(Data, timeout, fnSuccess, fnError, aButton) {

    //varLoadingMaskUnion.show();
    //Показываем форму с выбором склада (в котором будет работать сотрудник)
    var Params = [
        undefined, //UO_idCall
        true, //UO_Center
        true, //UO_Modal
        1     // 1 - Новое, 2 - Редактировать
    ]
    ObjectEditConfig("viewKKMLoader", Params);

    //Переменные
    //Функция "success"
    if (!fnSuccess) fnSuccess = ExecuteSuccess;
    //Функция "success"
    if (!fnError) fnError = ErrorSuccess;


    //$('.Responce').html("");

    //UrlServer = $("#SetServer").val();
    if (UrlServer == "AddIn") {

        KkmServer.Execute(function (message) {
            ExecuteSuccess(message, {}, {});
        }, Data);

    } else {

        if (timeout == undefined) {
            timeout = 60000; //Минута - некоторые драйверы при работе выполняют интерактивные действия с пользователем - тогда увеличте тайм-аут.
        }

        var JSon;
        if (typeof (Data) == "string") {
            JSon = Data;
        } else {
            JSon = $.toJSON(Data);
        };


        /*
        //Передача параметров функции
        success:function(a,b,c){//в эту ф-цию надо передать дополнительные параметры
            FuncSuccess(a,b,c,'some-argument');
        },
        */

        $.support.cors = true;
        var jqXHRvar = $.ajax({
            type: 'POST',
            async: true,
            timeout: timeout,
            url: UrlServer + ((UrlServer == "") ? window.location.protocol + "//" + window.location.host + "/" : "/") + 'Execute',
            crossDomain: true,
            dataType: 'json',
            contentType: 'application/json; charset=UTF-8',
            processData: false,
            data: JSon,
            headers: (User !== "" || Password !== "") ? { "Authorization": "Basic " + btoa(User + ":" + Password) } : "",
            //success: fnSuccess,
            success: function (Rezult, textStatus, jqXHR) {//в эту ф-цию надо передать дополнительные параметры
                //fnSuccess(Rezult, textStatus, jqXHR, aButton);
                ExecuteSuccess_LoaderMask(fnSuccess, Rezult, textStatus, jqXHR, aButton);

                //Если закрыли смену, то заполнить переменную!
                /*if (Data.Command == "CloseShift") {
                    varSmenaClose2 = true;
                }*/
            },
            error: fnError
        });
    };
}

// Функция вызываемая после обработки команды - обработка возвращаемых данных
function ExecuteSuccess(Rezult, textStatus, jqXHR) {

    //----------------------------------------------------------------------
    // ОБЩЕЕ
    //----------------------------------------------------------------------
    var Responce = "";
    //document.getElementById('Slip').textContent = "";

    if (Rezult.Status == 0) {
        Responce = Responce + "Статус: " + "Ok" + "\r\n";
    } else if (Rezult.Status == 1) {
        Responce = Responce + "Статус: " + "Выполняется" + "\r\n";
    } else if (Rezult.Status == 2) {
        Responce = Responce + "Статус: " + "Ошибка!" + "\r\n";
    } else if (Rezult.Status == 3) {
        Responce = Responce + "Статус: " + "Данные не найдены!" + "\r\n";
    };

    // Текст ошибки
    if (Rezult.Error != undefined && Rezult.Error != "") {
        Responce = Responce + "Ошибка: " + Rezult.Error + "\r\n";
    }

    if (Rezult != undefined) {
        var JSon = JSON.stringify(Rezult, "", 4);
        Responce = Responce + "JSON ответа: \r\n" + JSon + "\r\n";
        if (Rezult.Slip != undefined) {
            //document.getElementById('Slip').textContent = Rezult.Slip;
            alert(Rezult.Slip);
        }
    }

    //document.getElementById('Responce').textContent = Responce;
    //$(".Responce").text(Responce);
    alert(Responce);
}
function ExecuteSuccess_LoaderMask(fnSuccess, Rezult, textStatus, jqXHR, aButton) {
    
    if (Ext.getCmp("viewKKMLoader")) { Ext.getCmp("viewKKMLoader").close(); }
    
    fnSuccess(Rezult, textStatus, jqXHR, aButton);
}

// Функция вызываемая при ошибке передачи данных
function ErrorSuccess(jqXHR, textStatus, errorThrown) {

    if (Ext.getCmp("viewKKMLoader")) { Ext.getCmp("viewKKMLoader").close(); }

    //document.getElementById('Responce').innerHTML = "Ошибка передачи данных по HTTP протоколу: " + errorThrown;
    //$('.Responce').html("Ошибка передачи данных по HTTP протоколу");

    alert("Ошибка передачи данных по HTTP протоколу: " + errorThrown);
}







//////////////////////////////////////////////////////////////////////////////////////////
//  КОМАНДЫ ФИСКАЛЬНЫХ РЕГИСТРАТОРОВ
//////////////////////////////////////////////////////////////////////////////////////////

// Печать чеков
function RegisterCheck(aButton, FormData, fnSuccess, TypeCheck, IsBarCode) { //NumDevice, TypeCheck, IsBarCode, 
    
    FormData.DirNomenName = FormData.DirNomenName
        .replace(" / ", "/").replace(" / ", "/").replace(" / ", "/").replace(" / ", "/")
        .replace(" /", "/").replace(" /", "/").replace(" /", "/").replace(" /", "/")
        .replace("/ ", "/").replace("/ ", "/").replace("/ ", "/").replace("/ ", "/");

    if (!FormData.SignMethodCalculation) { FormData.SignMethodCalculation = 4; }
    if (!FormData.SignCalculationObject) { FormData.SignCalculationObject = 1; }
    if (!FormData.AdvancePayment) { FormData.AdvancePayment = 0; }

    // Подготовка данных команды
    var Data = {
        // Команда серверу
        Command: "RegisterCheck",

        //***********************************************************************************************************
        // ПОЛЯ ПОИСКА УСТРОЙСТВА
        //***********************************************************************************************************
        // Номер устройства. Если 0 то первое не блокированное на сервере
        NumDevice: varKKMSNumDevice,
        // ИНН ККМ для поиска. Если "" то ККМ ищется только по NumDevice,
        // Если NumDevice = 0 а InnKkm заполнено то ККМ ищется только по InnKkm
        InnKkm: "",
        //---------------------------------------------
        // Заводской номер ККМ для поиска. Если "" то ККМ ищется только по NumDevice,
        KktNumber: "",
        // **********************************************************************************************************

        // Время (сек) ожидания выполнения команды.
        //Если За это время команда не выполнилась в статусе вернется результат "NotRun" или "Run"
        //Проверить результат еще не выполненной команды можно командой "GetRezult"
        //Если не указано или 0 - то значение по умолчанию 60 сек.
        // Поле не обязательно. Это поле можно указывать во всех командах
        Timeout: 30,
        // Уникальный идентификатор команды. Любая строка из 40 символов - должна быть уникальна для каждой подаваемой команды
        // По этому идентификатору можно запросить результат выполнения команды
        // Поле не обязательно
        IdCommand: guid(),
        // Это фискальный или не фискальный чек
        IsFiscalCheck: true,
        // Тип чека;
        // 0 – продажа;                             10 – покупка;
        // 1 – возврат продажи;                     11 - возврат покупки;
        // 8 - продажа только по ЕГАИС (обычный чек ККМ не печатается)
        // 9 - возврат продажи только по ЕГАИС (обычный чек ККМ не печатается)
        TypeCheck: TypeCheck,
        // Не печатать чек на бумагу
        NotPrint: false, //true,
        // Количество копий документа
        NumberCopies: 0,
        // Продавец, тег ОФД 1021
        CashierName: lanDirEmployeeName, //"Kазакова Н.А.",
        // ИНН продавца тег ОФД 1203
        CashierVATIN: varKKMSCashierVATIN, //"430601071197",
        // Телефон или е-Майл покупателя, тег ОФД 1008
        // Если чек не печатается (NotPrint = true) то указывать обязательно
        // Формат: Телефон +{Ц} Email {С}
        ClientAddress: FormData.ClientAddress, //"client@server.ru",
        // Aдрес электронной почты отправителя чека тег ОФД 1117 (если задан при регистрации можно не указывать)
        // Формат: Email {С}
        SenderEmail: "", //"sochi@mama.com",
        // Система налогообложения (СНО) применяемая для чека
        // Если не указанно - система СНО настроенная в ККМ по умолчанию
        // 0: Общая ОСН
        // 1: Упрощенная УСН (Доход)
        // 2: Упрощенная УСН (Доход минус Расход)
        // 3: Единый налог на вмененный доход ЕНВД
        // 4: Единый сельскохозяйственный налог ЕСН
        // 5: Патентная система налогообложения
        // Комбинация разных СНО не возможна
        // Надо указывать если ККМ настроена на несколько систем СНО
        TaxVariant: varKKMSTaxVariant,



        // Строки чека
        CheckStrings: [
            /*
            // Строка с печатью простого текста
            {
                PrintText: {
                    //При вставке в текст символов ">#10#<" строка при печати выровнеется по центру, где 10 - это на сколько меньше станет строка ККТ
                    Text: ">#2#<ООО \"БОНИТО\"",
                    Font: 1,
                },
            },
            */

            // Строка с печатью текста определенным шрифтом
            { PrintText: { Text: "<<->>" }, },
            //{ PrintText: { Text: "..." }, },
            //{ PrintText: { Text: "<<*>>" }, },



            // Строка с печатью фискальной строки
            {
                Register: {
                    // Наименование товара 64 символа
                    Name: FormData.DirNomenName, //"Сапоги женские DF-3099-1",
                    // Количество товара (3 знака после запятой)
                    Quantity: FormData.Quantity, //Ext.getCmp("Quantity" + aButton.UO_id).getValue(), //3,
                    // Цена за шт. без скидки (2 знака после запятой)
                    Price: FormData.PriceCurrency, //100,
                    // Конечная сумма строки с учетом всех скидок/наценок; (2 знака после запятой)
                    Amount: FormData.Amount, //0.01,
                    // Отдел, по которому ведется продажа
                    Department: 0,
                    // НДС в процентах или ТЕГ НДС: 0 (НДС 0%), 10 (НДС 10%), 18 (НДС 18%), -1 (НДС не облагается), 118 (НДС 18/118), 110 (НДС 10/110)
                    Tax: varKKMSTax, //0,
                    //Штрих-код EAN13 для передачи в ОФД (не печатется)
                    EAN13: "", //"1254789547853",
                    // Признак способа расчета. тег ОФД 1214. Для ФФД.1.05 и выше обязательное поле
                    // 1: "ПРЕДОПЛАТА 100% (Полная предварительная оплата до момента передачи предмета расчета)"
                    // 2: "ПРЕДОПЛАТА (Частичная предварительная оплата до момента передачи предмета расчета)"
                    // 3: "АВАНС"
                    // 4: "ПОЛНЫЙ РАСЧЕТ (Полная оплата, в том числе с учетом аванса в момент передачи предмета расчета)"
                    // 5: "ЧАСТИЧНЫЙ РАСЧЕТ И КРЕДИТ (Частичная оплата предмета расчета в момент его передачи с последующей оплатой в кредит )"
                    // 6: "ПЕРЕДАЧА В КРЕДИТ (Передача предмета расчета без его оплаты в момент его передачи с последующей оплатой в кредит)"
                    // 7: "ОПЛАТА КРЕДИТА (Оплата предмета расчета после его передачи с оплатой в кредит )"
                    SignMethodCalculation: FormData.SignMethodCalculation, //4,
                    // Признак предмета расчета. тег ОФД 1212. Для ФФД.1.1 и выше обязательное поле
                    // 1: "ТОВАР (наименование и иные сведения, описывающие товар)"
                    // 2: "ПОДАКЦИЗНЫЙ ТОВАР (наименование и иные сведения, описывающие товар)"
                    // 3: "РАБОТА (наименование и иные сведения, описывающие работу)"
                    // 4: "УСЛУГА (наименование и иные сведения, описывающие услугу)"
                    // 5: "СТАВКА АЗАРТНОЙ ИГРЫ (при осуществлении деятельности по проведению азартных игр)"
                    // 6: "ВЫИГРЫШ АЗАРТНОЙ ИГРЫ (при осуществлении деятельности по проведению азартных игр)"
                    // 7: "ЛОТЕРЕЙНЫЙ БИЛЕТ (при осуществлении деятельности по проведению лотерей)"
                    // 8: "ВЫИГРЫШ ЛОТЕРЕИ (при осуществлении деятельности по проведению лотерей)"
                    // 9: "ПРЕДОСТАВЛЕНИЕ РИД (предоставлении прав на использование результатов интеллектуальной деятельности или средств индивидуализации)"
                    // 10: "ПЛАТЕЖ (аванс, задаток, предоплата, кредит, взнос в счет оплаты, пени, штраф, вознаграждение, бонус и иной аналогичный предмет расчета)"
                    // 11: "АГЕНТСКОЕ ВОЗНАГРАЖДЕНИЕ (вознаграждение (банковского)платежного агента/субагента, комиссионера, поверенного или иным агентом)"
                    // 12: "СОСТАВНОЙ ПРЕДМЕТ РАСЧЕТА (предмет расчета, состоящем из предметов, каждому из которых может быть присвоено вышестоящее значение"
                    // 13: "ИНОЙ ПРЕДМЕТ РАСЧЕТА (предмет расчета, не относящемуся к предметам расчета, которым может быть присвоено вышестоящее значение"
                    SignCalculationObject: FormData.SignCalculationObject, //1,
                    // Единица измерения предмета расчета. Можно не указывать
                    MeasurementUnit: "шт",
                    // Код товарной номенклатуры Тег ОФД 1162 (Новый классификатор товаров и услуг. Пока не утвержден налоговой. Пока не указывать)
                    // 4 символа – код справочника; последующие 8 символовт – код группы товаров; последние 20 символов – код идентификации товара
                    NomenclatureCode: "",

                },
            },
            { PrintText: { Text: "<<->>" }, },


            /*
            {
                PrintText: {
                    Text: "Спасибо за покупку!",
                    Font: 1, // 1-4, 0 - по настройкам ККМ
                    Intensity: 15, // 1-15, 0 - по настройкам ККМ
                },
            },
            { PrintText: { Text: "<<*>>" }, },
            */
        ],

        // Наличная оплата (2 знака после запятой)
        Cash: FormData.SumNal,
        // Сумма электронной оплаты (2 знака после запятой)
        ElectronicPayment: FormData.SumBezNal,
        // Сумма из предоплаты (зачетом аванса) (2 знака после запятой)
        AdvancePayment: FormData.AdvancePayment, //0,
        // Сумма постоплатой(в кредит) (2 знака после запятой)
        Credit: 0,
        // Сумма оплаты встречным предоставлением (сертификаты, др. мат.ценности) (2 знака после запятой)
        CashProvision: 0,

    };

    
    //Если чек без ШК то удаляем строку с ШК
    if (IsBarCode == false) {
        //Data.Cash = 100;
        for (var i = 0; i < Data.CheckStrings.length; i++) {
            if (Data.CheckStrings[i] != undefined && Data.CheckStrings[i].BarCode != undefined) {
                Data.CheckStrings[i].BarCode = null;
            };
            if (Data.CheckStrings[i] != undefined && Data.CheckStrings[i].PrintImage != undefined) {
                Data.CheckStrings[i].PrintImage = null;
            };
        };
    };
    

    //Скидываем данные об агенте - т.к.у Вас невярнека ККТ не зарегистрирована как Агент.
    for (var i = 0; i < Data.CheckStrings.length; i++) {
        if (Data.CheckStrings[i] != undefined && Data.CheckStrings[i].Register != undefined) {
            Data.CheckStrings[i].Register.AgentSign = null;
            Data.CheckStrings[i].Register.AgentData = null;
            Data.CheckStrings[i].Register.PurveyorData = null;
        };
    };


    // Вызов команды
    ExecuteCommand(Data, undefined, fnSuccess, undefined, aButton);


    // Возвращается JSON:
    //{
    //    "CheckNumber": 1,    // Номер документа
    //    "SessionNumber": 23, // Номер смены
    //    "URL": "https://ofd.ru/rec/7708806062/0000000006018032/9999078900002287/106/4160536402",
    //    "QRCode": "t=20170904T140900&s=0.01&fn=9999078900002287&i=106&fp=4160536402&n=1",
    //    "Command": "RegisterCheck",
    //    "Error": "",  // Текст ошибки если была - обязательно показать пользователю - по содержанию ошибки можно в 90% случаях понять как ее устранять
    //    "Status": 0   // Ok = 0, Run(Запущено на выполнение) = 1, Error = 2, NotFound(устройство не найдено) = 3, NotRun = 4
    //}

}

// Чек коррекции
function RegisterCorrectionCheck(NumDevice, TypeCheck) {

    // Подготовка данных команды
    var Data = {
        // Команда серверу
        Command: "RegisterCheck",
        // Номер устройства. Если 0 то первое не блокированное на сервере
        NumDevice: NumDevice,
        // ИНН ККМ. Если "" то ККМ ищется только по NumDevice,
        // Если NumDevice = 0 а InnKkm заполнено то ККМ ищется только по InnKkm
        InnKkm: "",
        // Время (сек) ожидания выполнения команды.
        //Если За это время команда не выполнилась в статусе вернется результат "NotRun" или "Run"
        //Проверить результат еще не выполненной команды можно командой "GetRezult"
        //Если не указано или 0 - то значение по умолчанию 60 сек.
        // Поле не обязательно. Это поле можно указывать во всех командах
        Timeout: 30,
        // Уникальный идентификатор команды. Любая строка из 40 символов - должна быть уникальна для каждой подаваемой команды
        // По этому идентификатору можно запросить результат выполнения команды
        // Поле не обязательно
        IdCommand: guid(),
        // Это фискальный или не фискальный чек
        IsFiscalCheck: true,
        // Тип чека;
        // Для новых ККМ:
        // 2 – корректировка приход;
        // 12 – корректировка расход;
        TypeCheck: TypeCheck,
        //Тип коррекции 0 - самостоятельно 1 - по предписанию
        СorrectionType: 1,
        // Продавец, тег ОФД 1021
        CashierName: "Иванов И.И.",
        // ИНН продавца тег ОФД 1203
        CashierVATIN: "430601071197",
        // Не печатать чек на бумагу
        NotPrint: false,
        // Количество копий документа
        NumberCopies: 0,
        // Система налогообложения (СНО) применяемая для чека
        // Если не указанно - система СНО настроенная в ККМ по умолчанию
        // 0: Общая ОСН
        // 1: Упрощенная УСН (Доход)
        // 2: Упрощенная УСН (Доход минус Расход)
        // 3: Единый налог на вмененный доход ЕНВД
        // 4: Единый сельскохозяйственный налог ЕСН
        // 5: Патентная система налогообложения
        // Комбинация разных СНО не возможна
        // Надо указывать если ККМ настроена на несколько систем СНО
        TaxVariant: varKKMSTaxVariant, //"",
        // Наименование основания для коррекции Тег ОФД 1177
        CorrectionBaseName: "Предписание налоговой",
        // Дата документа основания для коррекции Тег ОФД 1178
        CorrectionBaseDate: '2017-06-21T15:30:45',
        // Номер документа основания для коррекции Тег ОФД 1179
        CorrectionBaseNumber: "MOS-4516",

        // Строки чека
        CheckStrings: [
            // В сторно только не фискальные строки и ШК!!!!!!!!!!!!!!!!!!!!!
            {
                PrintText: {
                    Text: "Это чек корректровки. Делается только по предписанию налоговой или глав.буха.",
                    Font: 2, // 1-4, 0 - по настройкам ККМ
                    Intensity: 0, // 1-15, 0 - по настройкам ККМ
                },
            },
        ],

        // Сумма расчета, игнорируется для ККТ ФФД 1.0
        Amount: 1.21,

        // Сумма коррекции Наличной оплаты (2 знака после запятой)
        Cash: 1.11,
        // Сумма коррекции электронной оплаты (2 знака после запятой)
        ElectronicPayment: 0.01,
        // Сумма коррекции предоплаты (зачетом аванса) (2 знака после запятой)
        AdvancePayment: 0.02,
        // Сумма коррекции постоплатой(в кредит) (2 знака после запятой)
        Credit: 0.03,
        // Сумма коррекции встречным предоставлением (2 знака после запятой)
        CashProvision: 0.04,

        // Сумма коррекции НДС чека по ставке Без НДС, игнорируется для ККТ ФФД 1.0 (2 знака после запятой)
        SumTaxNone: 0.01,
        // Сумма коррекции НДС чека по ставке 18%, игнорируется для ККТ ФФД 1.0 (2 знака после запятой)
        SumTax18: 0.02,
        // Сумма коррекции НДС чека по ставке 10%, игнорируется для ККТ ФФД 1.0 (2 знака после запятой)
        SumTax10: 0.03,
        // Сумма коррекции НДС чека по ставке 0%, игнорируется для ККТ ФФД 1.0 (2 знака после запятой)
        SumTax0: 0.04,
        // Сумма коррекции НДС чека по ставке 18/118%, игнорируется для ККТ ФФД 1.0 (2 знака после запятой)
        SumTax118: 0.05,
        // Сумма коррекции НДС чека по ставке 10/110%, игнорируется для ККТ ФФД 1.0 (2 знака после запятой)
        SumTax110: 0.06,
    };

    // Вызов команды
    ExecuteCommand(Data);

    // Возвращается JSON:
    //{
    //    "CheckNumber": 1,    // Номер документа
    //    "SessionNumber": 23, // Номер смены
    //    "QRCode": "t=20170115T155100&s=0.01&fn=99078900002287&i=120&fp=2216493490&n=2", // URL проверки чека, где: t-дата-время, s-сумма документа, fn-номер ФН, i-номер документа, fp-фискальная подпись, n-тип документа
    //    "Command": "RegisterCheck",
    //    "Error": "",  // Текст ошибки если была - обязательно показать пользователю - по содержанию ошибки можно в 90% случаях понять как ее устранять
    //    "Status": 0   // Ok = 0, Run(Запущено на выполнение) = 1, Error = 2, NotFound(устройство не найдено) = 3, NotRun(Ждет очереди) = 4, AlreadyDone(Выполнено ранее) = 5, ErrorInEGAIS(Ошибка ЕГАИС) = 6
    //}

}

// Пример печати  произвольного текста (Слип-чека)
function PrintSlip(NumDevice, IsBarCode) {

    // Подготовка данных команды
    var Data = {
        Command: "RegisterCheck",
        NumDevice: NumDevice,
        IsFiscalCheck: false,
        NotPrint: false,
        IdCommand: guid(),

        // Строки чека
        CheckStrings: [
            //При вставке в текст символов ">#10#<" строка при печати выровнеется по центру, где 10 - это на сколько меньше станет строка ККТ
            {
                PrintText: {
                    Text: ">#2#<ООО \"Рога и копыта\"",
                    Font: 1,
                },
            },
            // При вставке в текст в середину строки символов "<#10#>" Левая часть строки будет выравнена по левому краю, правая по правому, где 10 - это на сколько меньше станет строка ККТ
            // При вставке в текст в середину строки символов "<#10#>>" Левая часть строки будет выравнена по правому краю, правая по правому, где 10 - отступ от правого клая
            { PrintText: { Text: "<<->>" }, },
            { PrintText: { Text: "Пример №1 печати поля:<#16#>154,41" }, },
            { PrintText: { Text: "2-рое поле:<#16#>4,00" }, },
            { PrintText: { Text: "<<->>" }, },
            { PrintText: { Text: "Пример №2 печати поля:<#8#>>4,00" }, },
            { PrintText: { Text: "2-рое поле:<#8#>>1544,00" }, },
            { PrintText: { Text: "<<->>" }, },
            // Строка с печатью штрих-кода
            {
                BarCode: {
                    // Тип штрих-кода: "EAN8", "EAN13", "CODE39", "QR", "PDF417".
                    BarcodeType: "EAN13",
                    // Значение штрих-кода
                    Barcode: "1254789547853",
                },
            },
            { PrintText: { Text: "<<->>" }, },
            // Строка с печатью текста определенным шрифтом
            {
                PrintText: {
                    Text: "Шрифт № 1",
                    Font: 1, // 1-4, 0 - по настройкам ККМ
                    Intensity: 15, // 1-15, 0 - по настройкам ККМ
                },
            },
            {
                PrintText: {
                    Text: "Шрифт № 2",
                    Font: 2, // 1-4, 0 - по настройкам ККМ
                    Intensity: 10, // 1-15, 0 - по настройкам ККМ
                },
            },
            {
                PrintText: {
                    Text: "Шрифт № 3",
                    //Text: "Это мега крутой товар. Продается во всех магазинах страны. Покупайте только у нас",
                    Font: 3, // 1-4, 0 - по настройкам ККМ
                    Intensity: 5, // 1-15, 0 - по настройкам ККМ
                },
            },
            {
                PrintText: {
                    Text: "Шрифт № 4",
                    Font: 4, // 1-4, 0 - по настройкам ККМ
                    Intensity: 0, // 1-15, 0 - по настройкам ККМ
                },
            },
            {
                BarCode: {
                    // Тип штрих-кода: "EAN8", "EAN13", "CODE39", "QR", "PDF417".
                    BarcodeType: "QR",
                    // Значение штрих-кода
                    Barcode: "12345DFG",
                },
            },
        ],
    };

    //Если чек без ШК то удаляес строку с ШК
    if (IsBarCode == false) {
        //Data.Cash = 100;
        for (var i = 0; i < Data.CheckStrings.length; i++) {
            if (Data.CheckStrings[i] != undefined && Data.CheckStrings[i].BarCode != undefined) {
                Data.CheckStrings[i].BarCode = null;
            }
        }
    }

    // Вызов команды
    ExecuteCommand(Data);
}

// Открыть смену
function OpenShift(NotPrint) {

    // Подготовка данных команды
    var Data = {
        // Команда серверу
        Command: "OpenShift",
        // Номер устройства. Если 0 то первое не блокированное на сервере
        NumDevice: varKKMSNumDevice, //NumDevice,
        // Id устройства. Строка. Если = "" то первое не блокированное на сервере
        IdDevice: "",
        // Продавец, тег ОФД 1021
        CashierName: lanDirEmployeeName, //"Kазакова Н.А.",
        // ИНН продавца тег ОФД 1203
        CashierVATIN: varKKMSCashierVATIN, //"430601071197",
        // Не печатать чек на бумагу
        NotPrint: NotPrint,
        // Уникальный идентификатор команды. Любая строока из 40 символов - должна быть уникальна для каждой подаваемой команды
        // По этому идентификатору можно запросить результат выполнения команды
        IdCommand: guid(),
    };
    // Вызов команды
    ExecuteCommand(Data);

    // Возвращается JSON:
    //{
    //    "CheckNumber": 1,    // Номер документа
    //    "SessionNumber": 23, // Номер смены
    //    "QRCode": "t=20170904T141100&fn=9999078900002287&i=108&fp=605445600",
    //    "Command": "OpenShift",
    //    "Error": "",  // Текст ошибки если была - обязательно показать пользователю - по содержанию ошибки можно в 90% случаях понять как ее устранять
    //    "Status": 0   // Ok = 0, Run(Запущено на выполнение) = 1, Error = 2, NotFound(устройство не найдено) = 3, NotRun = 4
    //}

}

// Печать закрытия смены
function CloseShift(NotPrint) {

    // Подготовка данных команды
    var Data = {
        // Команда серверу
        Command: "CloseShift",
        // Номер устройства. Если 0 то первое не блокированное на сервере
        NumDevice: varKKMSNumDevice,
        // Продавец, тег ОФД 1021
        CashierName: lanDirEmployeeName, //"Иванов И.И.",
        // ИНН продавца тег ОФД 1203
        CashierVATIN: varKKMSCashierVATIN, //"430601071197",
        // Не печатать чек на бумагу
        NotPrint: NotPrint,
        // Id устройства. Строка. Если = "" то первое не блокированное на сервере
        IdDevice: "",
        // Уникальный идентификатор команды. Любая строока из 40 символов - должна быть уникальна для каждой подаваемой команды
        // По этому идентификатору можно запросить результат выполнения команды
        IdCommand: guid(),
    };

    // Вызов команды
    ExecuteCommand(Data);

    // Возвращается JSON:
    //{
    //    "CheckNumber": 1,    // Номер документа
    //    "SessionNumber": 23, // Номер смены
    //    "QRCode": "t=20170904T141100&fn=9999078900002287&i=108&fp=605445600",
    //    "Command": "CloseShift",
    //    "Error": "",  // Текст ошибки если была - обязательно показать пользователю - по содержанию ошибки можно в 90% случаях понять как ее устранять
    //    "Status": 0   // Ok = 0, Run(Запущено на выполнение) = 1, Error = 2, NotFound(устройство не найдено) = 3, NotRun = 4
    //}

}

// Печать X отчета
function XReport() {
    
    // Подготовка данных команды
    var Data = {
        // Команда серверу
        Command: "XReport",
        // Номер устройства. Если 0 то первое не блокированное на сервере
        NumDevice: varKKMSNumDevice, //NumDevice,
        // Id устройства. Строка. Если = "" то первое не блокированное на сервере
        IdDevice: "",
        // Уникальный идентификатор команды. Любая строока из 40 символов - должна быть уникальна для каждой подаваемой команды
        // По этому идентификатору можно запросить результат выполнения команды
        IdCommand: guid(),
    };

    // Вызов команды
    ExecuteCommand(Data);
}

// Печать Отчет диагностики соединения с ОФД
function OfdReport(NumDevice) {

    // Подготовка данных команды
    var Data = {
        // Команда серверу
        Command: "OfdReport",
        // Номер устройства. Если 0 то первое не блокированное на сервере
        NumDevice: varKKMSNumDevice,
        // Продавец, тег ОФД 1021
        CashierName: lanDirEmployeeName, //"Kазакова Н.А.",
        // ИНН продавца тег ОФД 1203
        CashierVATIN: varKKMSCashierVATIN, //"430601071197",
        // Уникальный идентификатор команды. Любая строока из 40 символов - должна быть уникальна для каждой подаваемой команды
        // По этому идентификатору можно запросить результат выполнения команды
        // Поле не обязательно
        IdCommand: guid()

    };

    // Вызов команды
    ExecuteCommand(Data);
}

// Открыть денежный ящик
function OpenCashDrawer(NumDevice) {
    
    // Подготовка данных команды
    var Data = {
        // Команда серверу
        Command: "OpenCashDrawer",
        // Номер устройства. Если 0 то первое не блокированное на сервере
        NumDevice: NumDevice,
        // Уникальный идентификатор команды. Любая строока из 40 символов - должна быть уникальна для каждой подаваемой команды
        // По этому идентификатору можно запросить результат выполнения команды
        // Поле не обязательно
        IdCommand: guid()

    };

    // Вызов команды
    ExecuteCommand(Data);
}

// Печать чека внесения
function DepositingCash(Amount, bPrint) {
    
    // Подготовка данных команды
    var Data = {
        // Команда серверу
        Command: "DepositingCash",
        // Номер устройства. Если 0 то первое не блокированное на сервере
        NumDevice: varKKMSNumDevice,
        // Продавец, тег ОФД 1021
        CashierName: lanDirEmployeeName, //"Kазакова Н.А.",
        // ИНН продавца тег ОФД 1203
        CashierVATIN: varKKMSCashierVATIN, //"430601071197",
        // Сумма внесения наличных
        Amount: Amount,
        // Не печатать чек на бумагу
        NotPrint: bPrint, //false,
        // Уникальный идентификатор команды. Любая строока из 40 символов - должна быть уникальна для каждой подаваемой команды
        // По этому идентификатору можно запросить результат выполнения команды
        // Поле не обязательно
        IdCommand: guid()

    };

    // Вызов команды
    ExecuteCommand(Data);
}

// Печать чека выемки
function PaymentCash(Amount, bPrint) {
    
    // Подготовка данных команды
    var Data = {
        // Команда серверу
        Command: "PaymentCash",
        // Номер устройства. Если 0 то первое не блокированное на сервере
        NumDevice: varKKMSNumDevice,
        // Продавец, тег ОФД 1021
        CashierName: lanDirEmployeeName, //"Kазакова Н.А.",
        // ИНН продавца тег ОФД 1203
        CashierVATIN: varKKMSCashierVATIN, //"430601071197",
        // Сумма выемки наличных
        Amount: Amount,
        // Не печатать чек на бумагу
        NotPrint: bPrint,
        // Уникальный идентификатор команды. Любая строока из 40 символов - должна быть уникальна для каждой подаваемой команды
        // По этому идентификатору можно запросить результат выполнения команды
        // Поле не обязательно
        IdCommand: guid()

    };

    // Вызов команды
    ExecuteCommand(Data);
}

// Получить данные последнего чека из ФН по номеру чека.
function GetDataCheck(FiscalNumber, NumberCopies) {

    if (FiscalNumber == undefined) {
        FiscalNumber = 0;
    };
    if (NumberCopies == undefined) {
        NumberCopies = 1;
    };

    // Подготовка данных команды
    var Data = {
        // Команда серверу
        Command: "GetDataCheck",
        // Номер устройства. Если 0 то первое не блокированное на сервере
        NumDevice: varKKMSNumDevice,
        // Уникальный идентификатор команды. Любая строока из 40 символов - должна быть уникальна для каждой подаваемой команды
        // По этому идентификатору можно запросить результат выполнения команды
        // Поле не обязательно
        IdCommand: guid(),
        // Фискальный номер (ФД) чека. Если 0 - то последний чек
        FiscalNumber: FiscalNumber,
        // Количество копий документа (копии печатаются на ленте)
        NumberCopies: 1
    };

    // Вызов команды
    ExecuteCommand(Data);

}

// Получить текущее состояние ККТ.
function GetDataKKT() {

    // Подготовка данных команды
    var Data = {
        // Команда серверу
        Command: "GetDataKKT",
        // Номер устройства. Если 0 то первое не блокированное на сервере
        NumDevice: varKKMSNumDevice,
        // Уникальный идентификатор команды. Любая строока из 40 символов - должна быть уникальна для каждой подаваемой команды
        // По этому идентификатору можно запросить результат выполнения команды
        // Поле не обязательно
        IdCommand: guid()

    };

    // Вызов команды
    ExecuteCommand(Data);

    // Возвращается JSON:
    //{
    //    "CheckNumber": 8,     // Номер последнего документа
    //    "SessionNumber": 24,  // Номер текущей смены
    //    "LineLength": 48,     // Ширина строки
    //    "URL": "",
    //    "Info": {
    //        "UrlServerOfd": "connect.ofd-ya.ru",
    //        "PortServerOfd": "7790",
    //        "NameOFD": "ООО \"Ярус\" (\"ОФД-Я\")",
    //        "UrlOfd": "",
    //        "InnOfd": "504404744207",
    //        "NameOrganization": "ООО \"Рога и Копыта\"",
    //        "TaxVariant": "0,3,5",                                // Описание смотри в команде KkmRegOfd
    //        "AddressSettle": "109097, Москва, ул. Ильинка, 9",    // Адрес установки
    //        "EncryptionMode": false,
    //        "OfflineMode": true,
    //        "AutomaticMode": false,
    //        "InternetMode": false,
    //        "BSOMode": false,
    //        "ServiceMode": true,
    //        "InnOrganization": "504404744207",
    //        "KktNumber": "0149060006000651",                      // Заводской номер
    //        "FnNumber": "99078900002287",                         // Номер ФН
    //        "RegNumber": "0149060006035849",                      // Регистрационный номер ККТ (из налоговой)
    //        "Command": "",
    //        "FN_IsFiscal": true,
    //        "OFD_Error": "",
    //        "OFD_NumErrorDoc": 32,
    //        "OFD_DateErrorDoc": "2017-01-13T14:56:00",
    //        "FN_DateEnd": "2018-02-01T00:00:00",
    //        "SessionState": 2                                     // Статус сессии 1-Закрыта, 2-Открыта, 3-Открыта, но закончилась (3 статус на старых ККМ может быть не опознан)
    //    },
    //    "Command": "GetDataKKT",
    //    "Error": "",  // Текст ошибки если была - обязательно показать пользователю - по содержанию ошибки можно в 90% случаях понять как ее устранять
    //    "Status": 0   // Ok = 0, Run(Запущено на выполнение) = 1, Error = 2, NotFound(устройство не найдено) = 3, NotRun = 4
    //}
}

// Асинхронная проверка выполнения команды!!
function GetRezult(IdCommand) {

    // Заново запрашиваем результат выполнения команды
    var Data = {
        // Команда серверу - запрос выволнеия команды
        Command: "GetRezult",
        // Уникальный идентификатор ранее поданной команды
        IdCommand: IdCommand,
    };

    // Вызываем запрос на получение результата с задержкой 2 секунды
    ExecuteCommand(Data);

};




//////////////////////////////////////////////////////////////////////////////////////////
//  КОМАНДЫ МЕНЕДЖЕРА СЕРВЕРА
//////////////////////////////////////////////////////////////////////////////////////////

// Получение списка ККМ
function List(NumDevice) {

    // Подготовка данных команды
    var Data = {
        // Команда серверу
        Command: "List",
        // Отбор по номеру устройства. Число. Если 0 или не указано то с любым номером
        NumDevice: NumDevice, //varKKMSNumDevice,
        // Отбор по ИНН. Строка. Если "" или не указано то первое не блокированное на сервере
        InnKkm: "",
        // Отбор активных. Булево. Если null или не указано то активные и не активные
        Active: null, // true/false,
        // Отбор выключенны-включенных
        OnOff: null, // true/false,
        // Отбор наличию ошибок ОФВ. Булево. Если null или не указано то с ошибками и без
        OFD_Error: null,
        // Все у которых дата не переданного док. в ОФД меньше указанной. Дата-время. Если null или не указано то любое
        OFD_DateErrorDoc: null, // Пример: '2100-01-01T00:00:00',
        // Все у которых дата окончания работы ФН меньше указанной. Дата-время. Если null или не указано то любое
        FN_DateEnd: null, // Пример: '2100-01-01T00:00:00',
        // Все у которых заканчивается память ФН; Булево. Если null или не указано то все
        FN_MemOverflowl: null,
        // Фискализированные или нет ФН; Булево. Если null или не указано то все
        FN_IsFiscal: null,
    };

    // Вызов команды
    ExecuteCommand(Data, undefined, FunctionProj_List_ExecuteSuccess, undefined);

    // Возвращается JSON:
    //{
    //    "ListUnit": [
    //          {
    //              "NumDevice": 2,
    //              "IdDevice": "6a6151a5-b352-485c-8f01-45da05d3df18",
    //              "OnOf": true,
    //              "Active": false,
    //              "TypeDevice": "Фискальный регистратор",
    //              "IdTypeDevice": "KkmStrihM",
    //              "IP": "192.168.137.111",
    //              "NameDevice": "<Не определено>",
    //              "KktNumber": "",
    //              "INN": "<Не определено>",
    //              "TaxVariant": "", // Описание смотри в команде KkmRegOfd
    //              "AddDate": "2017-01-13T14:55:16",
    //              "OFD_Error": "",
    //              "OFD_NumErrorDoc": 0,
    //              "OFD_DateErrorDoc": "0001-01-01T00:00:00",
    //              "FN_DateEnd": "0001-01-01T00:00:00",
    //              "FN_MemOverflowl": false,
    //              "FN_IsFiscal": false,
    //              "PaperOver": false
    //          },
    //    ],
    //    "Command": "List",
    //    "Error": "",  // Текст ошибки если была - обязательно показать пользователю - по содержанию ошибки можно в 90% случаях понять как ее устранять
    //    "Status": 0   // Ok = 0, Run(Запущено на выполнение) = 1, Error = 2, NotFound(устройство не найдено) = 3, NotRun = 4
    //}

}

// Включение/Выключение ККМ
function OnOffUnut(NumDevice) {

    // Подготовка данных команды
    var Data = {
        // Команда серверу
        Command: "OnOffUnut",
        // Номер устройства. Если 0 то любое
        NumDevice: NumDevice,
        // Id устройства. Строка. Если = "" то любое
        IdDevice: "",
        // Включение/Выключение
        Active: false,
    };

    // Вызов команды
    ExecuteCommand(Data);

}

// Получение списка ККМ
function ExecuteJSON() {
    ExecuteCommand($("#JSON").val());
}



//////////////////////////////////////////////////////////////////////////////////////////
//  ВСПОМОГАТЕЛЬНОЕ
//////////////////////////////////////////////////////////////////////////////////////////

// Герерация GUID
function guid() {

    function S4() {
        return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
    }

    return (S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4());
}

// Расчет ключа для получения суб-лицензии
function GetKeySubLicensing(Email, Password) {

    // ВНИМАНИЕ!
    // Расчет ключа для получения суб-лицензии должен происходить на сервере (а не у чужого клиента-суб-лицензиата)
    // НЕ передавайте свой пароль клиенту-суб-лицензиата
    // Данный пример только для понимания как гереировать ключ на Вашем сервере!!

    //хеш пароля
    var Hash1 = md5(Password).toUpperCase();

    // солим
    var Hash2 = md5(Hash1 + "Qwerty").toUpperCase();

    // формируем дату
    var now = new Date();
    var formated_date = "" + now.getFullYear() + ((now.getMonth() + 1) < 10 ? "0" : "") + (now.getMonth() + 1) + (now.getDate() < 10 ? "0" : "") + now.getDate();
    //now.getMonth()+1 потому что getMonth() возвращает 0..11 а не 1..12

    //добавляем данные лицензии
    var Hash3 = md5(Hash2 + formated_date).toUpperCase();

    // Имя машины или имя клиента max 100 символов
    // Указывать не обязательно
    // Позволяет быстрее найти серийный номер в личном кабинете
    var Name = "Клиент-1";

    // формируем ключ
    if (Name == "") {
        var Key = Email + "/" + Hash3;
    } else {
        var Key = Name + ":" + Email + "/" + Hash3;
    };

    return Key;

}

// Вычисление хеша md5
function md5(s) {

    return hex_md5(s);

    var hexcase = 0;   /* hex output format. 0 - lowercase; 1 - uppercase        */
    var b64pad = "";  /* base-64 pad character. "=" for strict RFC compliance   */

    /*
     * These are the functions you'll usually want to call
     * They take string arguments and return either hex or base-64 encoded strings
     */
    function hex_md5(s) { return rstr2hex(rstr_md5(str2rstr_utf8(s))); }
    function b64_md5(s) { return rstr2b64(rstr_md5(str2rstr_utf8(s))); }
    function any_md5(s, e) { return rstr2any(rstr_md5(str2rstr_utf8(s)), e); }
    function hex_hmac_md5(k, d) { return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
    function b64_hmac_md5(k, d) { return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
    function any_hmac_md5(k, d, e) { return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

    /*
     * Perform a simple self-test to see if the VM is working
     */
    function md5_vm_test() {
        return hex_md5("abc").toLowerCase() == "900150983cd24fb0d6963f7d28e17f72";
    }

    /*
     * Calculate the MD5 of a raw string
     */
    function rstr_md5(s) {
        return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
    }

    /*
     * Calculate the HMAC-MD5, of a key and some data (raw strings)
     */
    function rstr_hmac_md5(key, data) {
        var bkey = rstr2binl(key);
        if (bkey.length > 16) bkey = binl_md5(bkey, key.length * 8);

        var ipad = Array(16), opad = Array(16);
        for (var i = 0; i < 16; i++) {
            ipad[i] = bkey[i] ^ 0x36363636;
            opad[i] = bkey[i] ^ 0x5C5C5C5C;
        }

        var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
        return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
    }

    /*
     * Convert a raw string to a hex string
     */
    function rstr2hex(input) {
        try { hexcase } catch (e) { hexcase = 0; }
        var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
        var output = "";
        var x;
        for (var i = 0; i < input.length; i++) {
            x = input.charCodeAt(i);
            output += hex_tab.charAt((x >>> 4) & 0x0F)
                + hex_tab.charAt(x & 0x0F);
        }
        return output;
    }

    /*
     * Convert a raw string to a base-64 string
     */
    function rstr2b64(input) {
        try { b64pad } catch (e) { b64pad = ''; }
        var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var output = "";
        var len = input.length;
        for (var i = 0; i < len; i += 3) {
            var triplet = (input.charCodeAt(i) << 16)
                | (i + 1 < len ? input.charCodeAt(i + 1) << 8 : 0)
                | (i + 2 < len ? input.charCodeAt(i + 2) : 0);
            for (var j = 0; j < 4; j++) {
                if (i * 8 + j * 6 > input.length * 8) output += b64pad;
                else output += tab.charAt((triplet >>> 6 * (3 - j)) & 0x3F);
            }
        }
        return output;
    }

    /*
     * Convert a raw string to an arbitrary string encoding
     */
    function rstr2any(input, encoding) {
        var divisor = encoding.length;
        var i, j, q, x, quotient;

        /* Convert to an array of 16-bit big-endian values, forming the dividend */
        var dividend = Array(Math.ceil(input.length / 2));
        for (i = 0; i < dividend.length; i++) {
            dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
        }

        /*
         * Repeatedly perform a long division. The binary array forms the dividend,
         * the length of the encoding is the divisor. Once computed, the quotient
         * forms the dividend for the next step. All remainders are stored for later
         * use.
         */
        var full_length = Math.ceil(input.length * 8 /
            (Math.log(encoding.length) / Math.log(2)));
        var remainders = Array(full_length);
        for (j = 0; j < full_length; j++) {
            quotient = Array();
            x = 0;
            for (i = 0; i < dividend.length; i++) {
                x = (x << 16) + dividend[i];
                q = Math.floor(x / divisor);
                x -= q * divisor;
                if (quotient.length > 0 || q > 0)
                    quotient[quotient.length] = q;
            }
            remainders[j] = x;
            dividend = quotient;
        }

        /* Convert the remainders to the output string */
        var output = "";
        for (i = remainders.length - 1; i >= 0; i--)
            output += encoding.charAt(remainders[i]);

        return output;
    }

    /*
     * Encode a string as utf-8.
     * For efficiency, this assumes the input is valid utf-16.
     */
    function str2rstr_utf8(input) {
        var output = "";
        var i = -1;
        var x, y;

        while (++i < input.length) {
            /* Decode utf-16 surrogate pairs */
            x = input.charCodeAt(i);
            y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
            if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF) {
                x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
                i++;
            }

            /* Encode output as utf-8 */
            if (x <= 0x7F)
                output += String.fromCharCode(x);
            else if (x <= 0x7FF)
                output += String.fromCharCode(0xC0 | ((x >>> 6) & 0x1F),
                    0x80 | (x & 0x3F));
            else if (x <= 0xFFFF)
                output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                    0x80 | ((x >>> 6) & 0x3F),
                    0x80 | (x & 0x3F));
            else if (x <= 0x1FFFFF)
                output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                    0x80 | ((x >>> 12) & 0x3F),
                    0x80 | ((x >>> 6) & 0x3F),
                    0x80 | (x & 0x3F));
        }
        return output;
    }

    /*
     * Encode a string as utf-16
     */
    function str2rstr_utf16le(input) {
        var output = "";
        for (var i = 0; i < input.length; i++)
            output += String.fromCharCode(input.charCodeAt(i) & 0xFF,
                (input.charCodeAt(i) >>> 8) & 0xFF);
        return output;
    }

    function str2rstr_utf16be(input) {
        var output = "";
        for (var i = 0; i < input.length; i++)
            output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
                input.charCodeAt(i) & 0xFF);
        return output;
    }

    /*
     * Convert a raw string to an array of little-endian words
     * Characters >255 have their high-byte silently ignored.
     */
    function rstr2binl(input) {
        var output = Array(input.length >> 2);
        for (var i = 0; i < output.length; i++)
            output[i] = 0;
        for (var i = 0; i < input.length * 8; i += 8)
            output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32);
        return output;
    }

    /*
     * Convert an array of little-endian words to a string
     */
    function binl2rstr(input) {
        var output = "";
        for (var i = 0; i < input.length * 32; i += 8)
            output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF);
        return output;
    }

    /*
     * Calculate the MD5 of an array of little-endian words, and a bit length.
     */
    function binl_md5(x, len) {
        /* append padding */
        x[len >> 5] |= 0x80 << ((len) % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;

        var a = 1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d = 271733878;

        for (var i = 0; i < x.length; i += 16) {
            var olda = a;
            var oldb = b;
            var oldc = c;
            var oldd = d;

            a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
            d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
            c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
            b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
            a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
            d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
            c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
            b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
            a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
            d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
            c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
            b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
            a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
            d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
            c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
            b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);

            a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
            d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
            c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
            b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
            a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
            d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
            c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
            b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
            a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
            d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
            c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
            b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
            a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
            d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
            c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
            b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);

            a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
            d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
            c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
            b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
            a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
            d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
            c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
            b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
            a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
            d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
            c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
            b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
            a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
            d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
            c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
            b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);

            a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
            d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
            c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
            b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
            a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
            d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
            c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
            b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
            a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
            d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
            c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
            b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
            a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
            d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
            c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
            b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);

            a = safe_add(a, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
        }
        return Array(a, b, c, d);
    }

    /*
     * These functions implement the four basic operations the algorithm uses.
     */
    function md5_cmn(q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
    }
    function md5_ff(a, b, c, d, x, s, t) {
        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
    }
    function md5_gg(a, b, c, d, x, s, t) {
        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
    }
    function md5_hh(a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5_ii(a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
    }

    /*
     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
     * to work around bugs in some JS interpreters.
     */
    function safe_add(x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    }

    /*
     * Bitwise rotate a 32-bit number to the left.
     */
    function bit_rol(num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    }
}



//////////////////////////////////////////////////////////////////////////////////////////
//  ИНТЕРФЕЙС
//////////////////////////////////////////////////////////////////////////////////////////

function SetServer() {
    UrlServer = $("#SetServer").val();
}

function SetDevice() {
    Device = document.getElementById('SetDevice').value;
}



//////////////////////////////////////////////////////////////////////////////////////////
//  МОИ ФУНКЦИИ
//////////////////////////////////////////////////////////////////////////////////////////

//Получение списка ККМ
function FunctionProj_List_ExecuteSuccess(Rezult, textStatus, jqXHR) {
    //----------------------------------------------------------------------
    // ОБЩЕЕ
    //----------------------------------------------------------------------
    var Responce = "";
    //document.getElementById('Slip').textContent = "";

    if (Rezult.Status == 0) {
        Responce = Responce + "Статус: " + "Ok" + "\r\n";
    } else if (Rezult.Status == 1) {
        Responce = Responce + "Статус: " + "Выполняется" + "\r\n";
    } else if (Rezult.Status == 2) {
        Responce = Responce + "Статус: " + "Ошибка!" + "\r\n";
    } else if (Rezult.Status == 3) {
        Responce = Responce + "Статус: " + "Данные не найдены!" + "\r\n";
    };

    // Текст ошибки
    if (Rezult.Error != undefined && Rezult.Error != "") {
        Responce = Responce + "Ошибка: " + Rezult.Error + "\r\n";
    }

    if (Rezult != undefined) {
        var JSon = JSON.stringify(Rezult, "", 4);
        Responce = Responce + "JSON ответа: \r\n" + JSon + "\r\n";
        if (Rezult.Slip != undefined) {
            //document.getElementById('Slip').textContent = Rezult.Slip;
            alert(Rezult.Slip);
        }
    }
    
    //document.getElementById('Responce').textContent = Responce;
    //$(".Responce").text(Responce);
    //alert(Responce);

    /*
    Ext.Msg.alert(
        lanOrgName,
        Responce
    );
    */

    var sHTML =
        "<table border=1>" + 
        " <tr>" +
        "   <td>Active</td>" + 
        "   <td>AddDate</td>" + 
        "   <td>AddressSettle</td>" + 
        "   <td>FN_DateEnd</td>" + 
        "   <td>FN_MemOverflowl</td>" + 
        "   <td>FnNumber</td>" + 
        "   <td>INN</td>" + 
        "   <td>IP</td>" + 
        "   <td>IdDevice</td>" + 
        "   <td>IdTypeDevice</td>" + 
        "   <td>InnOfd</td>" + 
        "   <td>KktNumber</td>" + 
        "   <td>NameDevice</td>" + 
        "   <td>NameOrganization</td>" + 
        "   <td>NumDevice</td>" + 
        "   <td>OFD_DateErrorDoc</td>" + 
        "   <td>OFD_Error</td>" + 
        "   <td>OFD_NumErrorDoc</td>" + 
        "   <td>OnOff</td>" + 
        "   <td>PaperOver</td>" + 
        "   <td>RegNumber</td>" + 
        "   <td>TaxVariant</td>" + 
        "   <td>TypeDevice</td>" + 
        "   <td>Active</td>" + 
        "   <td>UnitName</td>" + 
        " </tr>";

    for (var i = 0; i < Rezult.ListUnit.length; i++) {
        sHTML +=
            "<tr>" + 
            "<td>" + Rezult.ListUnit[i].Active + "</td>" +
            "<td>" + Rezult.ListUnit[i].AddDate + "</td>" +
            "<td>" + Rezult.ListUnit[i].AddressSettle + "</td>" +
            "<td>" + Rezult.ListUnit[i].FN_DateEnd + "</td>" +
            "<td>" + Rezult.ListUnit[i].FN_MemOverflowl + "</td>" +
            "<td>" + Rezult.ListUnit[i].FnNumber + "</td>" +
            "<td>" + Rezult.ListUnit[i].INN + "</td>" +
            "<td>" + Rezult.ListUnit[i].IP + "</td>" +
            "<td>" + Rezult.ListUnit[i].IdDevice + "</td>" +
            "<td>" + Rezult.ListUnit[i].IdTypeDevice + "</td>" +
            "<td>" + Rezult.ListUnit[i].InnOfd + "</td>" +
            "<td>" + Rezult.ListUnit[i].KktNumber + "</td>" +
            "<td>" + Rezult.ListUnit[i].NameDevice + "</td>" +
            "<td>" + Rezult.ListUnit[i].NameOrganization + "</td>" +
            "<td>" + Rezult.ListUnit[i].NumDevice + "</td>" +
            "<td>" + Rezult.ListUnit[i].OFD_DateErrorDoc + "</td>" +
            "<td>" + Rezult.ListUnit[i].OFD_Error + "</td>" +
            "<td>" + Rezult.ListUnit[i].OFD_NumErrorDoc + "</td>" +
            "<td>" + Rezult.ListUnit[i].OnOff + "</td>" +
            "<td>" + Rezult.ListUnit[i].PaperOver + "</td>" +
            "<td>" + Rezult.ListUnit[i].RegNumber + "</td>" +
            "<td>" + Rezult.ListUnit[i].TaxVariant + "</td>" +
            "<td>" + Rezult.ListUnit[i].TypeDevice + "</td>" +
            "<td>" + Rezult.ListUnit[i].UnitName + "</td>" +
            "</tr>";
    }

    sHTML +=
        "</table>";


    //Ext.Msg.alert( lanOrgName, sHTML );

    Ext.Msg.show({
        title: lanOrgName,
        msg: sHTML,
        maxWidth: 1250,
        width: 1250
    });


}


